#version 430 core


struct PointLight {    
    vec3 position;
    float constant;
    vec3 ambient;
    float linear;
    vec3 diffuse;
    float quadratic;
    vec3 specular;
    float shininess;
};  
struct VisibleIndex
{
	int index;
};
#define LOCAL_TILE_SIZE 16

layout (local_size_x = LOCAL_TILE_SIZE, local_size_y = LOCAL_TILE_SIZE, local_size_z = 1)in;

layout(binding = 0, r32F)		
coherent uniform image2D  debug_image; //this is just for outputing test stuff like visible light count per tile
layout(binding = 1, std430) buffer  light_buffer
{ 
	PointLight light_data[]; 
};
layout(binding = 2, std430) buffer  visible_index_buffer
{ 
	VisibleIndex light_index[]; 
};

uniform int window_width;
uniform int window_height;
uniform int point_light_count;
uniform sampler2D depth_map;//this should be populated by a z prepass!!!
uniform mat4 proj;
uniform mat4 view;

shared int visible_light_indices[1024];
shared int visible_light_count;
shared uint max_depth_uint;
shared uint min_depth_uint;
shared float min_depth, max_depth;
shared ivec2 screen_size;
shared mat4 inv_proj;

shared vec4 frustum_planes[6];

void main()
{
  //[1]first we initialize shared stuff, find our tiles coords etc..
  ivec2 location = ivec2(gl_GlobalInvocationID.xy);
  ivec2 itemID = ivec2(gl_LocalInvocationID.xy);
  ivec2 tileID = ivec2(gl_WorkGroupID.xy);
  ivec2 tile_number = ivec2(gl_NumWorkGroups.xy);
  uint index = tileID.y * tile_number.x + tileID.x;
  if (gl_LocalInvocationIndex == 0)
  {
	  visible_light_count = 0;
	  max_depth_uint = 0;
	  min_depth_uint = 0xFFFFFFFF;
	  screen_size = ivec2(window_width, window_height);
	  inv_proj = inverse(proj);
  }
  barrier();
  
  //[2]now we find the smallest and largest depths for our (whole) 16x16 tile
  vec2 tex_coords = vec2(location) / screen_size;
  float depth = texture(depth_map, tex_coords).r;
  uint depth_uint = floatBitsToUint(depth);
  atomicMin(min_depth_uint, depth_uint);
  atomicMax(max_depth_uint, depth_uint);
  
  barrier();  
  //[3]now we calculate the culling frustum for each tile
  if (gl_LocalInvocationIndex == 0)
  {
	  
	min_depth = uintBitsToFloat(min_depth_uint);
	max_depth = uintBitsToFloat(max_depth_uint);
	vec4 vs_min_depth = (inv_proj * vec4(0,0,2 * min_depth - 1, 1));
	vec4 vs_max_depth = (inv_proj * vec4(0,0,2 * max_depth - 1, 1));
	vs_min_depth /= vs_min_depth.w;
	vs_min_depth /= vs_max_depth.w;
	min_depth = vs_min_depth.z;
	max_depth = vs_max_depth.z;
	  
	vec2 tile_scale = vec2(screen_size) * (1.0 / float(2 * LOCAL_TILE_SIZE));
	vec2 tile_bias = tile_scale - vec2(gl_WorkGroupID.xy);
	vec4 col1 = vec4(-proj[0][0] * tile_scale.x, proj[0][1], tile_bias.x, proj[0][3]);
	vec4 col2 = vec4(proj[1][0], -proj[1][1] * tile_scale.y, tile_bias.y, proj[1][3]);
	vec4 col4 = vec4(proj[3][0], proj[3][1], -1.0, proj[3][3]);

	frustum_planes[0] = col4 + col1;
	frustum_planes[1] = col4 - col1;
	frustum_planes[2] = col4 - col2;
	frustum_planes[3] = col4 + col2;
	frustum_planes[4] = vec4(0.0, 0.0, 1.0, -min_depth);
	frustum_planes[5] = vec4(0.0, 0.0, -1.0, max_depth);
	for (uint i = 0; i < 4; i++) {
		frustum_planes[i] *= 1.0f / length(frustum_planes[i].xyz);
	}
		
  }
  barrier();
  //[4]we cull the lights based on the frustum planes
  uint thread_count = LOCAL_TILE_SIZE * LOCAL_TILE_SIZE;
  uint pass_count = (point_light_count + thread_count - 1) / thread_count;
  float near_clip;
  for (uint i = 0; i < pass_count; ++i)
  {
	  uint light_idx = i * thread_count  + gl_LocalInvocationIndex;
	  if (light_idx >= point_light_count)break;
	  
	  vec3 light_position = light_data[light_idx].position;
	  float radius = light_data[light_idx].shininess; //this should change to its own attrib
	  vec4 vs_light_position = (view * vec4(light_position, 1.0)).xyzw;
	  bool in_frustum = true;
	  for (uint j = 0;j < 6 && in_frustum; ++j)
	  {
		  float d = dot(frustum_planes[j], vs_light_position);
		  in_frustum = (d >= -radius);
	  }
	  if (in_frustum)
	  {
		  uint offset = atomicAdd(visible_light_count, 1);
		  visible_light_indices[offset] = int(light_idx);
	  }
	  
  }
  barrier();
  imageStore(debug_image, location, vec4(float(visible_light_count), 0,0,0));
  barrier();
  //[5] One thread should fills the light index buffer, each tile has 1024 available spots
	if (gl_LocalInvocationIndex == 0) {
		uint offset = index * 1024; //tile's position in index array
		
		for (uint i = 0; i < visible_light_count; i++) {
			light_index[offset + i].index = visible_light_indices[i];
		}

		if(visible_light_count != 1024) {
			// if the whole (size 1024) index array is not filled, we insert a -1 at the end, for the FS to know when to stop
			light_index[offset + visible_light_count].index = -1;
		}
	}
  barrier();
}

